## 30

可以考虑将字符串转换成为ASCII数字。

## 31

1. 直接排序取前k大的值是O(nlgn)
2. 可以考虑利用快速排序中的某一个步骤

## 32 
 提示在3-7 基数排序视频中
## 33 
 提示在4-1 递归视频中
## 34 
 提示在4-3 递归视频中
## 35
 无 
## 36
参考视频中枚举集合的方法，求所有集合的子集，分别求和，筛选为0的项。注意去除空集。 
## 37
反转一个链表，可以看做反转第一个元素，再反转剩余部分的一个递归函数。 
## 38

s1,s2,s3,....sk代表S中的每个字符。 a1,a2,...am代表A中的每个字符。b1,b2,...bn代表B中的每个字符。 

如果S可以被A和B组成，那么要么S去掉第一个字符可以被：

1. A去掉第一个字符和B组成  (如果a1 === s1)
2. B去掉第一个字符和A组成 （如果b1 === s1)

## 45
使用递归，取出一半元素作为子集，然后比较和剩余元素的差值，返回。然后在上一级中比较返回的差值，求最小值。 
## 46
可以利用欧几里得迭代法，12和8的最大公约数等于12-8和8的最大公约数。

如果a>b,a/b存在最大公约数c。那么a=p*c, b=q*c。 

那么a-b=c*(p-q)，因此a-b和b也存在最大公约数c。

## 48
可以使用快慢两个指针遍历链表，快指针每次前进两个，慢指针每次前进1个。
## 49 

可以一边遍历，一边使用一个对象存链表的每项。但这样容易造成内存泄露，所以WeakMap了解下。
##55
提示：利用栈（周六课程讲解）