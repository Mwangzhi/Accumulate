
“数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读取数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储的，所以对CPU缓存不友好，没办法有效预读”，这里的CPU缓存机制指的是什么，为什么就数组更好了?
**参考答案：**
CPU在从内存中读取数据的时候，会先把读取到的数据加载到CPU缓存中。而CPU每次从内存中读取数据并不是只读取那个特定要访问的地址，而是读取一个数据快并保存到CPU缓存中，然后下次访问内存数据的时候会先从CPU缓存开始查找，如果找到就不需要再从内存中取。这样就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义：为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入的。

##### 如果字符串是通过单链表来存储的，那么该如何判断是一个回文字符串（也称为水仙花字串，比如goog）
**思路：**
- 1、快慢指针定位中间节点
- 2、从中间节点对后半部分逆序
- 3、前后半部分比较，判断是否是回文字符串

### 5个常见的链表操作
- 单链表反转
- 链表中环的检测
- 两个有序的链表合并
- 删除链表倒数第n个节点
- 求链表的中间节点
- 单链表存在环，如何找到入环点
- 判断两个单链表是否相交，如果相交，求出交点

### LRU算法
**思路：**
- 用单项链表实现。链表尾部是最近一次用过的缓存，链表头部是最久未被用过的缓存。
- 用数组实现
### 链表中环的检测
- 方法一：创建一个hashset，保留每次遍历到的节点，之后每遍历到一个节点时先去hashset查找是否存在。时间复杂度o(n),空间复杂度o(n)
- 方法二：创建两个指针，快指针和慢指针。快指针每次移动两个，慢指针每次移动一个，在循环过程中如果快、慢指针指向的元素相等了，那么链表有环